# 1.线程的概述
## 1.1线程的相关概念
- 进程(process)
> 1. 进程是计算机中的程序关于某个数据集合的一次运行活动,是操作系统进行资源分配与调度的基本单位.
> 2. 可以把进程简单的理解为正在操作系统上运行的一个程序
- 线程(thread)
> 1. 线程是进程的一个执行单元
> 2. 一个线程就是进程中一个单一顺序的控制流,进程的一个执行分支
> 3. 进程就是线程的容器,一个进程至少有一个线程,一个进程也可以有多个线程
> 4. 操作系统中,是按照进程为基本单位分配资源,每一个线程都有各自的线程栈,寄存器环境,线程的本地存储
> 5. 在java中线程作为最小的调度单位,进程作为资源分配的最小单位,在windows中进程是不活动的,只是作为线程的容器
- 主线程和子线程
> 1. JVM启动时会创建一个主线程,该线程负责执行main方法
> 2. java中的线程不是孤立存在的,线程之间存在一些联系.如果A线程创建的B线程,就称B线程是A线程的子线程,相应的A是B的父线程
- 串行并行和并发
> 有三个任务:
> - 任务A准备5分钟,等待10分钟
> - 任务B准备2分钟,等待8分钟
> - 任务C准备10分钟
>
> 时间:
> - 串行(Sequential): 所有任务逐个执行; 耗时: 15+10+10=35分钟
> - 并发(Concurrent): 等待时间可以开始下一个任务; 耗时:  5+2+10=17(C任务10分钟大于B任务8分钟,且B等待2分钟+C任务10分钟大于A任务等待10分钟)
> - 并行(Parallel): 3个任务同时开始,耗时取决于任务耗时最长的任务; 耗时: 15分钟
>
> 并发可以提高事务的处理效率,即一段时间可以处理完成更多的事务
> 并行是一种理想的并发,从硬件角度,单核CPU,操作系统使用时间片轮转技术,让用户感觉是并行执行的
>
# 2.应用
## 2.1案例一:异步调用
从方法的角度来讲,如果
- 需要等待结果的返回,才能继续运行就是同步
- 不需要等待结果的返回,就能继续运行就是同步
注意:同步在多线程还有另一层的意思,是让多个线程步调一致
### 1)设计-pro1.src.main.java.p2
多线程可以让方法执行变为异步的(即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了5秒钟，如果没有线程调度机制，这5秒调用者什么都做不了，其代码都得暂停..
### 2)结论
- 比如在项目中，视频的格式需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程
- tomcat的异步servlet也是类似的目的，让用户线程处理耗时比较长的操作，避免阻塞tomcat的工作线程
- ui程序中，开线程进行其他操作，避免阻塞ui线程
## 2.2应用之提升效率
### 1)设计
[Link-效率1](pdf/并发编程_应用.pdf)
### 2)结论
1. 在单核cpu下，多线程不能实际提高程序的运行效率，只是为了能够在不同的任务之间切换，多个线程轮流使用cpu，不至于一个线程总占用cpu，别的线程没法干活
2. 多核cpu可以并行跑多个线程，但能否提高程序的运行效率还是要分情况的
    - 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有的计算任务都可以拆分
    - 也不是所有的任务需要拆分，任务的目的如果不同，谈拆分和效率没什么意义
- IO操作不占用cpu，只要我们一般拷贝文件使用的是[阻塞IO]，这时相当于线程虽然不用cpu，但需要一直等待IO结束，没有充分利用线程。所以有了后面的[非阻塞IO]和[异步IO]优化

# 3.Java线程
## 3.1创建和运行线程
### 1)直接使用Thread
```java

@Slf4j
public class Test0 {
    public static void main(String[] args) {
        //创建线程并重写run方法
        Thread thread = new Thread() {
            @Override
            public void run() {
                log.debug("running");
            }
        };
        //给线程命名
        thread.setName("t1");
        //运行线程
        thread.start();
        log.debug("running");
    }
}
```
### 2)使用Runnable配合Thread
把**线程**和**任务**(要执行的代码)分开
- Thread 代表线程
- Runnable 可运行的任务(线程要执行的代码)
```java
@Slf4j
public class Test1 {
    public static void main(String[] args) {
        //1.创建任务对像(匿名内部类创建Runnable实现)
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                log.debug("hello");
            }
        };
        //2.创建线程对象
        Thread thread = new Thread(runnable);
        //3.运行
        thread.start();
        log.debug("hello");
    }
}
```
Java8以后使用Lambda精简代码
```java
@Slf4j
public class Test3 {
    public static void main(String[] args) {
        //创建任务对象(Lambda方式创建)
        Runnable runnable = ()-> log.debug("hello");
        //2.创建线程对象
        Thread thread = new Thread(runnable);
        //运行
        thread.start();
        log.debug("hello");
    }
}
```






